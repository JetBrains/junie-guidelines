# Nuxt.js Guidelines

You are an expert in JavaScript, Vue.js, TypeScript, Nuxt.js, and scalable web application development. You write secure, maintainable, and performant code following Nuxt.js and JavaScript best practices.

## JavaScript Best Practices
- Follow ESLint and Prettier configurations
- Use ES6+ features (arrow functions, destructuring, etc.)
- Prefer const over let, avoid var
- Use async/await for asynchronous operations
- Use template literals for string concatenation

**Explanation:**
- ESLint and Prettier enforce consistent code style and catch potential issues early
- Modern JavaScript features like arrow functions, destructuring, and spread operators make code more concise and readable
- Using const by default prevents accidental reassignment and makes code intentions clearer
- Async/await provides cleaner syntax for handling promises compared to .then() chains
- Template literals (`${variable}`) are more readable than string concatenation with + operators

## Nuxt Best Practices
- Use Composition API with `<script setup>` for components
- Leverage auto-imports for Vue and Nuxt composables
- Use Nuxt modules instead of manual configurations
- Implement proper error handling with error.vue

**Explanation:**
- Nuxt 3 is built on Vue 3, Vite, and TypeScript, offering significant performance improvements over Nuxt 2
- The Composition API with `<script setup>` provides better type inference, more concise code, and better organization of component logic
- Auto-imports reduce boilerplate by automatically importing Vue and Nuxt functions without explicit import statements
- Nuxt modules provide pre-configured functionality that follows best practices and reduces maintenance burden
- The error.vue file provides a centralized way to handle and display errors across your application

## Directory Structure
- Follow Nuxt.js 3 standard directory structure for better organization and auto-imports
- Keep generated directories (.nuxt, .output, node_modules) untouched
- Store stylesheets, fonts, and images in the assets directory
- Place Vue components in the components directory, organized by feature
- Store reusable logic in the composables directory with "use" prefix
- Use the layouts directory for page templates and structural components
- Place route guards in the middleware directory with appropriate naming
- Define routes in the pages directory following the file-based routing convention
- Store app-level functionality in the plugins directory
- Place static files in the public directory (formerly static in Nuxt 2)
- Use the server directory for server-side code (API routes, middleware)

**Explanation:**
- The `.nuxt` directory contains auto-generated files for your Vue application and should never be manually modified
- The `.output` directory holds production build files generated by `nuxt build` and should not be modified when deploying
- The `assets` directory is processed by build tools and is ideal for CSS, SCSS, fonts, and images that need processing
- The `components` directory benefits from auto-import functionality, eliminating the need for manual imports in templates; nested components are imported with their directory prefix (e.g., `ButtonPrimary` for `components/Button/Primary.vue`)
- The `composables` directory stores reusable logic with auto-import functionality; by default, only top-level composables are auto-imported, but this can be configured in `nuxt.config.js`
- The `content` directory works with the Nuxt Content module to create a file-based CMS using markdown, JSON, YAML, and CSV files
- The `layouts` directory provides structural templates for pages; each layout must have a single root element (not a `<slot>`) to enable transitions
- The `middleware` directory supports three types: anonymous (defined in pages), named (in middleware directory), and global (with .global suffix)
- The `pages` directory automatically generates routes based on file structure; creating `pages/about.vue` automatically creates the `/about` route
- The `plugins` directory contains code that runs at application startup; plugins are auto-registered and should not be added to nuxt.config separately
- The `public` directory (formerly `static` in Nuxt 2) is served at the server root and contains files that need to maintain their filenames
- The `server` directory contains server-side code including API routes, middleware, plugins, and utilities

## Pages and Routing
- Use dynamic routes appropriately
- Implement nested routes when logical
- Use middleware for route guards
- Leverage route validation with definePageMeta
- Use route parameters for dynamic content

**Explanation:**
- Dynamic routes (e.g., [id].vue) allow for reusing page components with different data based on parameters
- Nested routes help organize related pages and maintain UI consistency for sections of your application
- Middleware provides a clean way to implement authentication, analytics, or other cross-cutting concerns
- definePageMeta allows you to define metadata for pages including layout, middleware, and validation
- Route parameters should be validated to prevent unexpected behavior and improve security

## Components
- Create reusable components in the components directory
- Use TypeScript for props
- Use defineModel instead of a manual implementation of custom v-model
- Use script setup (with TS by default)
- Use props destructuring instead of withDefaults
- Implement proper component naming (PascalCase)
- Use slots for flexible component content
- Organize components in subdirectories by feature

**Explanation:**
- Components in Nuxt 3 are auto-imported, so proper organization is crucial for maintainability
- TypeScript for props provides better type safety, autocompletion, and documentation
- defineModel simplifies two-way binding and is the recommended approach in Vue 3.4+
- Script setup with TypeScript provides a more concise syntax and better type inference
- Props destructuring with default values is cleaner than using withDefaults
- PascalCase naming distinguishes components from HTML elements and follows Vue conventions
- Slots allow components to be more flexible and reusable across different contexts
- Organizing by feature (e.g., /components/auth/, /components/products/) improves discoverability

## Composables
- Place reusable logic in composables directory
- Follow the "use" prefix naming convention
- Keep composables focused on a single responsibility
- Properly type composables with TypeScript
- Use built-in composables when available

**Explanation:**
- Composables extract and reuse stateful logic across components, improving code reuse
- The "use" prefix (e.g., useCart, useAuth) is a convention that makes composables easily identifiable
- Single responsibility makes composables easier to test, maintain, and understand
- TypeScript typing improves developer experience with better autocomplete and error detection
- Nuxt provides many built-in composables (useHead, useFetch, etc.) that are optimized for the framework

## State Management
- prefer useState when possible
- use Pinia for more complex state management
- Avoid global state when component or page-level state is sufficient
- Do not use ref for global state
- Structure stores by domain/feature
- Implement proper typing for state

**Explanation:**
- useState is a built-in Nuxt 3 composable that provides reactive and SSR-friendly state
- Pinia is the recommended store for complex applications, offering better TypeScript support and devtools integration
- Overusing global state makes applications harder to test and reason about
- Using ref for global state can lead to reactivity issues across components and during SSR
- Domain-based store organization (e.g., user store, product store) improves maintainability
- TypeScript typing for state prevents errors and improves developer experience

## API Calls
- Use useFetch or useAsyncData only for reactive data fetching
- Composables should only be used in `setup` or in another composable - not `onMounted` or in a function triggered later on
- Implement proper error handling for API calls
- Use $fetch for direct API calls (or when no reactivity is necessary/intended)
- Create composables for complex operations
- Leverage server routes for sensitive operations

**Explanation:**
- useFetch and useAsyncData are optimized for Nuxt's server and client rendering but should only be used when reactivity is needed
- Composables with useAsyncData/useFetch must be called during setup to work properly with SSR and hydration
- Proper error handling improves user experience and helps with debugging
- $fetch is a built-in fetch wrapper with automatic error handling and request/response interceptors
- Composables for API operations centralize API-related logic and make it easier to maintain
- Server routes (/server/api/) keep sensitive operations and API keys secure on the server

## TypeScript
- Use TypeScript for better type safety
- Define interfaces and types for data structures
- Use generics when appropriate
- Leverage auto-imports for types
- Avoid using "any" type
- write erasableSyntaxOnly compliant code only (no enums, namespaces, and class parameter properties)

**Explanation:**
- TypeScript catches type-related errors at compile time rather than runtime
- Well-defined interfaces document the shape of your data and improve code quality
- Generics allow for reusable components and functions that work with different types
- Nuxt 3 can auto-import types from your codebase, reducing boilerplate
- Using "any" defeats the purpose of TypeScript and should be avoided when possible
- erasableSyntaxOnly compliant code ensures better compatibility with JavaScript and avoids TypeScript-only features that don't have direct JavaScript equivalents

## Performance
- Implement proper code-splitting
- Use lazy loading for components when appropriate
- Optimize images with Nuxt Image
- Implement proper caching strategies
- Use server components for data-heavy operations

**Explanation:**
- Code-splitting reduces initial bundle size by only loading code when needed
- Lazy loading components (with defineAsyncComponent) improves initial page load times
- Nuxt Image automatically optimizes images with proper sizing, formats, and lazy loading
- Caching strategies like stale-while-revalidate improve perceived performance
- Server components in Nuxt 3 allow heavy data processing to happen on the server, sending only the result to the client

## SEO
- Use definePageMeta for page-level metadata
- Implement proper head management with useHead
- Use semantic HTML elements
- Ensure accessibility compliance

**Explanation:**
- definePageMeta allows you to define SEO-related metadata for each page
- useHead provides a composable API to manage <head> tags including title, meta, and links
- Semantic HTML improves accessibility and helps search engines understand your content
- Accessibility compliance ensures your site works for all users and improves SEO

## Testing
- Write unit tests for components and composables
- Implement end-to-end tests for critical user flows
- Test both positive and negative scenarios

**Explanation:**
- Unit tests verify that individual components and composables work correctly in isolation
- End-to-end tests ensure that critical user flows work correctly from the user's perspective
- Testing negative scenarios (errors, edge cases) is as important as testing the happy path
